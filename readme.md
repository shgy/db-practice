为加深对数据库的理解，了解SQL调优的细节。 对presto的源码进行研究，探索Query Engine的实现细节。自行定义了project, 命名为db-practice。


v1.2版本的功能特性如下：
1. 实现JOIN的功能



步骤：
1. selectBase.g4支持JOIN语法
2. 解析出JOIN必备字段后，实现JOIN Operator
3. 实现JOIN相关的操作


问题：
1. presto的Page/Block机制
2. presto的Join实现机制



# 处理细节
antlr4 -package org.example.antlr -no-listener -visitor .\SqlBase.g4


使用antlr解析SQL语句，抽取出SQL语句中关键部分后，需要有个分析的过程，需要处理的事项如下：
1. 校验SQL语句查询的表是否存在。
2. 检验SQL语句查询的字段是否是表定义的字段，这就需要元数据。 各种查看表结构的操作只需要查询元数据即可。
3. 检验查询语句中使用的函数是否存在。
4. 解析出字段别名以及归属的数据表。
在前面的实现中，出于聚焦核心问题的考量，这一步是略过的。但是对于供用户使用的软件，这些检验是必不可少的。

在实现中，我们参考Presto的Operator实现了查询表，输出查询结果的操作。这是不是Presto特有的设计呢？
并不是，参考相关的文档后，可以简单对数据的实现进行简单的梳理。
在业界，有三种常见的数据库查询引擎执行模型。
1. 火山模型：数据库界已经很成熟的解释计算模型，该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 next() 函数。
2. 物化模型：每个 operator 一次处理所有的输入，处理完之后将所有结果一次性输出。
3. 向量化/批处理模型：向量化模型和火山模型 类似，每个operator需要实现一个next() 函数，但是每次调用next() 函数会返回一批的元组（tuples），而不是一个元组，所以向量化模型也可称为批处理模型。 向量化模型是火山模型和物化模型的折衷。

看了相关介绍后，感觉本质上都是火山模型，后面两种是在其基础上的优化。这里面的：向量化，列式存储，pipeline在Presto中都有实现。

了解完理论知识后，问题自然而然就出来了。Presto中是如何将这些理论落地的？

1. 火山模型概念的落地
首先Presto中实现了各种类型的Operator来处理对应的操作，例如：TableScanOperator，LimitOperator等。
   
2. 批处理模型的落地 

这些Operator接收的数据，不是数据库中的一行记录，而是一个Page，一个Page中封装了多条记录，例如我们最常接触的是从MySQL这类关系型数据库中取数据，对应到Presto中是RecordPageSource。
一个Page默认最多4096条记录。Page中，由于通常会查询多个字段，所以每个字段对应一个Block,该字段的列数据单独存储在一个Block中，这就是所谓的列式存储。这样执行字段的过滤操作时，只处理一个Block就可以了。
由于每个字段有不同的数据类型，所以Presto定义了Type,通常我们会用到如下的Type， 对应的类结构图如下：（简单来说就是数值型和字符串）
接下来看一下各个类型的数据是如何装载到Block中，
   以Integer类型为例：
   以Varchar类型为例：

装载到Block中，如何封装到Page中呢？
定义一个Block类型的数组即可。每个字段给一个唯一的下标编号，从0开始。这样就能跟Block数组关联起来

==========




















参考：
https://zhuanlan.zhihu.com/p/41562506